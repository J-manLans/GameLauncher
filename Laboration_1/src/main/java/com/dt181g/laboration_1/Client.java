package com.dt181g.laboration_1;

import java.util.Random;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The {@code Client} class represents a client that requests and utilizes a {@code WorkerThread}
 * from the {@code ThreadManager}. Once the client has finished utilizing the thread, it returns
 * the thread back to the manager.
 * Each {@code Client} runs in its own thread and interacts with a {@code WorkerThread} to perform tasks.
 * @author Joel Lansgren
 */
public class Client extends Thread {
        private final Object clientLock = new Object();
        private Random randomizer = new Random();
        private int randNum = randomizer.nextInt(101) + 50;
        private boolean threadDone = false;
        private final ThreadManager manager = ThreadManager.INSTANCE;
        private WorkerThread workerThread;

        /**
         * Constructs a new {@code Client} with the given name.
         * @param name the name of the client.
         */
        public Client(final String name) {
            this.setName(name);
        }

        /**
         * Returns the instances random number.
         * @return the instances random number
         */
        public int getRandNum() {
            return this.randNum;
        }

        /**
         * Updates the client's random number by applying an additional layer of randomness.
         *
         * @param randomNum the modified random number generated by the worker thread,
         * based on the original number provided by the client.
         */
        public void updateRandNum(final int randomNum) {
            this.randNum = randomNum;
        }

        /**
         * Notifies the client that the {@code WorkerThread} has finished its task.
         * This method is called by the {@code WorkerThread} when it completes its work.
         */
        public void notifyWorksDone() {
            synchronized (this.clientLock) {
                this.threadDone = true;
                this.clientLock.notify();
            }
        }

        /**
         * The {@code Client}'s main logic. The client retrieves a {@code WorkerThread} from the manager,
         * assigns itself to the thread, and waits for the thread to complete its work before returning the thread
         * to the pool.
         */
        @Override
        public void run() {
            this.workerThread = this.manager.getThread();
            this.workerThread.setClient(this);

            System.out.println(
                String.format(
                    "%s gives %s its random number",
                    this.getName(),
                    this.workerThread.getName()
                    )
            );
            workerThread.notifyToDoWork();

            synchronized (this.clientLock) {
                while (!this.threadDone) {
                    try {
                        this.clientLock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

            System.out.println(
                String.format(
                    "%s is returned to the pool. %s leaves the building with the random number %d.",
                    this.workerThread.getName(),
                    this.getName(),
                    this.randNum
                )
            );
            this.workerThread.setClient(null);
            this.manager.returnThread(this.workerThread);
            this.workerThread = null;
        }
}
